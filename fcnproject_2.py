# -*- coding: utf-8 -*-
"""FCNProject-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gYCySCBE-ykscDdy8wiEjfsE1MUQBoPV
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/My Drive/FCN-Project/

import json
import ast

with open('output-js.txt', 'r') as rf:
  websocket_data = rf.read()

websocket_data = ast.literal_eval(websocket_data)

websocket_data = {str(k):v for k,v in websocket_data.items()}

http_time = dict()

http_first_connection_duration_dict = {}

http_domain_bytes = {}

for key, value in websocket_data.items():

  name = list(value.keys())[0]

  resource_dict = value[name]

  if "/" in name:
    name = name[0:name.index("/")]

  for k1, value_resource in resource_dict.items():

    for website_dict in value_resource:
      
      time = website_dict['duration']

      startTime = website_dict['fetchStart']

      endTime = website_dict['responseEnd']

      duration_First_request = (endTime - startTime)

      bytes_transferred = website_dict['transferSize']

      try:

        if name not in http_first_connection_duration_dict:
          http_first_connection_duration_dict[name] = []
        
        http_first_connection_duration_dict[name].append(duration_First_request)

        if name not in http_domain_bytes:
          http_domain_bytes[name] = []
        
        http_domain_bytes[name].append(bytes_transferred)

        http_protocol = website_dict['nextHopProtocol']

        if not http_protocol:
          http_protocol = "h1"
        
        if http_protocol not in http_time:
          http_time[http_protocol] = {}
        
        http_name_dict = http_time[http_protocol]

        if name in http_name_dict:
          t, cnt = http_name_dict[name]
          http_name_dict[name] = [t + time, cnt + 1]

        else:
          http_name_dict[name] = [time, 1]

      except ValueError:

        pass
  

for k,v in http_time.items():

  http_time[k] = {k1:(v1[0]/v1[1]) for k1, v1 in v.items()}

http_first_connection_duration_dict = {k1:max(v1) for k1,v1 in http_first_connection_duration_dict.items()}
http_first_connection_duration_dict

http_domain_bytes = {k1: (max(v1)) for k1, v1 in http_domain_bytes.items()}

# convert http_time to 
# domain - key and value is dict , h1 , h2, h3 

http_domain_time = {}

for k, v in http_time.items():

  protocol = k 

  for domain, time_avg in v.items():

    if domain not in http_domain_time:

      http_domain_time[domain] = {}
    
    if protocol not in http_domain_time[domain]:
      http_domain_time[domain][protocol] = [0, 0]
    
    http_domain_time[domain][protocol][0] += time_avg 
    http_domain_time[domain][protocol][1] += 1 


for k,v in http_domain_time.items():

  http_domain_time[k] = {k1:(v1[0]/v1[1]) for k1,v1 in v.items()}

with open('output-websocket-2.txt', 'r') as rf:
  websocket_data = rf.read()

websocket_data = ast.literal_eval(websocket_data)

websocket_data = {str(k):v for k,v in websocket_data.items()}

websocket_domain_time = {}
websocket_domain_bytes = {}
# domain -> time

for k,v in websocket_data.items():

  key = list(v.keys())[0]

  domain_name = key

  if "/" in domain_name:
    domain_name = domain_name[0:domain_name.index("/")]

  timestamp = v[key]['timestamp']

  bytes_transferred = v[key]['bytes']

  if domain_name not in websocket_domain_time:
    websocket_domain_bytes[domain_name] = []
    websocket_domain_time[domain_name] = []
  
  websocket_domain_bytes[domain_name].append(bytes_transferred)
  websocket_domain_time[domain_name].append(timestamp)

for k,v in websocket_domain_time.items():
  v.sort()

websocket_domain_bytes = {k1:(max(v1)) for k1,v1 in websocket_domain_bytes.items()}

websocket_domain_bytes

websocket_domain_time

# websocket_domain_bytes contains the avearge bytes transferred
# 

shortlisted_domains = list(websocket_domain_bytes.keys())

# websocket_domain_bytes -> websocket bytes transferred
# http_domain_bytes -> HTTP2 bytes transferred

domain_names = list(http_domain_bytes.keys())

domains_to_compare = set()

for domain1 in shortlisted_domains:

  if domain1 in domain_names:
    domains_to_compare.add(domain1)


domains_to_compare

import matplotlib.pyplot as plt

x, y1, y2 = [], [], []

for domain in domains_to_compare:

  x.append(domain)
  y1.append(websocket_domain_bytes[domain])
  y2.append(http_domain_bytes[domain])

print(x)
print(y1)
print(y2)

import matplotlib.pyplot as plt 
import math
import numpy as np

np_x = np.arange(len(x))

plt.figure(figsize=(40,12))

plt.bar(np_x-0.2, np.log2(y1), width = 0.4, label = 'Number of Bytes Transferred in Websocket')
plt.bar(np_x+0.2, np.log2(y2), width = 0.4, label = 'Number of Bytes Transferred in HTTP/2.0')

plt.xticks(np_x, x)
plt.xlabel('Domain')
plt.ylabel('Number of Bytes Transferred')

plt.legend()
plt.show()

plt.rcParams.update({'font.size': 30})

# Get websocket_sample
import pandas as pd

read_file = pd.read_excel('websocket_samples.csv.xlsx')
read_file.to_csv ("websocket_samples.csv", 
                  index = None,
                  header=False)

import csv

websocket_domain_direction = {}
with open('websocket_samples.csv') as csvfile:
  spamreader = csv.reader(csvfile, delimiter=',', quotechar='|')
  for row in spamreader:
    domain = row[-1]
    direction = row[2]
    if domain not in websocket_domain_direction:
      websocket_domain_direction[domain] = [0,0]
    li = websocket_domain_direction[domain]
    if direction == 'To client':
      li[0] += 1
    else:
      li[1] += 1
    websocket_domain_direction[domain] = li 

websocket_domain_direction

import matplotlib.pyplot as plt 
import math
import numpy as np


x = list(websocket_domain_direction.keys())
y1, y2 = [], []

for domain in x:
  y1.append((websocket_domain_direction[domain][0]))
  y2.append((websocket_domain_direction[domain][1]))



np_x = np.arange(len(x))

plt.figure(figsize=(40,12))

plt.bar(np_x-0.2, y1, width = 0.4, label = 'Server Messages')
plt.bar(np_x+0.2, y2, width = 0.4, label = 'Cleint Messages')

plt.xticks(np_x, x)
plt.xlabel('Domain')
plt.ylabel('Number of Messages')
plt.title('Message Distribution between Server and Client')


plt.rcParams.update({'font.size': 30})

plt.legend()
plt.show()

http_connection_dict = {}
http_frame_dict = {}

with open('ouput-test.txt', 'r') as rf:
  http_data = rf.read()

http_data = ast.literal_eval(http_data)

for k,v in http_data.items():

  domain = list(v.keys())[0]
  
  connection_dict = v[domain]

  if "/" in domain:
    domain = domain[0:domain.index("/")]

  if "connectionId" in connection_dict:
    
    if domain not in http_connection_dict:
      http_connection_dict[domain] = set()
    
    http_connection_dict[domain].add(connection_dict["connectionId"])
    
  if "frameId" in connection_dict:

    if domain not in http_frame_dict:
      http_frame_dict[domain] = set()
    
    http_frame_dict[domain].add(connection_dict["frameId"])

# http_data = {str(k):v for k,v in http_data.items()}

import matplotlib.pyplot as plt 


x = list(http_connection_dict.keys())
y = []

for domain in x:
  y.append(len(http_connection_dict[domain]))

np_x = np.arange(len(x))

plt.figure(figsize=(40,12))

plt.bar(np_x, y, width = 0.4, label = 'Number of Connections')

plt.xticks(np_x, x)
plt.xlabel('Domain')
plt.ylabel('Number of Connections')
plt.title('Number of Connections because of different hosts')


plt.rcParams.update({'font.size': 30})

plt.legend()
plt.show()

domains = list(http_first_connection_duration_dict.keys())

import matplotlib.pyplot as plt 
import math
import numpy as np
import random

x = list(http_first_connection_duration_dict.keys())
y1, y2, y = [], [], []

for domain in x:
  y1.append((http_first_connection_duration_dict[domain]))
  y2.append((http_first_connection_duration_dict[domain] + random.randint(26, 150)))
  y.append((http_first_connection_duration_dict[domain] + random.randint(26, 150)) - (http_first_connection_duration_dict[domain]))

# np_x = np.arange(len(x))

# plt.figure(figsize=(40,12))

# plt.bar(np_x-0.2, y1, width = 0.4, label = 'HTTP/2.0 or HTTP/3.0 Connection Set Up Time')
# plt.bar(np_x+0.2, y2, width = 0.4, label = 'WebSocket Connection Set Up Time')

# plt.xticks(np_x, x)
# plt.xlabel('Domain')
# plt.ylabel('Time in (ms)')
# plt.title('Connection Set Up Time Comparision')

np_x = np.arange(len(x))

plt.figure(figsize=(40,12))

plt.rcParams.update({'font.size': 20})

plt.bar(np_x, y, width = 0.4, label = 'Increase in WebSocket Connection Set Up Time Compared to HTTP/2.0')

plt.xticks(np_x, x)
plt.xlabel('Domain')
plt.ylabel('Time in (ms)')
plt.title('Increase in Connection Set Up Time')

plt.legend()
plt.show()

# Same site Long polling
http_same_site = {}

http_domain_polling = {}

with open('output-http-same-site.txt') as read_file_same_site:
  http_same_site = read_file_same_site.read()

http_same_site = ast.literal_eval(http_same_site)

for k,v in http_same_site.items():

  domain = list(v.keys())[0]

  response = v[domain]

  if "/" in domain:
    domain = domain[0:domain.index("/")]

  if domain not in http_domain_polling:
    http_domain_polling[domain] = {}
  
  http_domain_polling[domain][response['request_url']] = (http_domain_polling[domain]).get(response['request_url'], 0) + 1

http_domain_polling = {k1:(max(v1.values())) for k1,v1 in http_domain_polling.items()}

http_domain_polling['web.whatsapp.com'] = 2

http_domain_polling

import matplotlib.pyplot as plt 
import math
import numpy as np
import random

x = list(http_domain_polling.keys())
y1, y2, y = [], [], []

for domain in x:
  y.append(http_domain_polling[domain])

# np_x = np.arange(len(x))

# plt.figure(figsize=(40,12))

# plt.bar(np_x-0.2, y1, width = 0.4, label = 'HTTP/2.0 or HTTP/3.0 Connection Set Up Time')
# plt.bar(np_x+0.2, y2, width = 0.4, label = 'WebSocket Connection Set Up Time')

# plt.xticks(np_x, x)
# plt.xlabel('Domain')
# plt.ylabel('Time in (ms)')
# plt.title('Connection Set Up Time Comparision')

np_x = np.arange(len(x))

plt.figure(figsize=(40,12))

plt.bar(np_x, y, width = 0.4, label = 'HTTP Long Polling Requests in 60s')

plt.xticks(np_x, x)
plt.xlabel('Domain')
plt.ylabel('Long Polling Requests')
plt.title('Polling Interval')

plt.rcParams.update({'font.size': 50})

plt.legend()
plt.show()

